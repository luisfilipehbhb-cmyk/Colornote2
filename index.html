<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minhas Anota√ß√µes</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: #f5f5f5;
            padding: 0;
            margin: 0;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-height: 100vh;
        }

        .header {
            background: #4CAF50;
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .notes-area {
            padding: 0;
        }

        textarea {
            width: 100%;
            min-height: 100vh;
            height: auto;
            border: none;
            font-size: 16px;
            line-height: 1.6;
            resize: none;
            outline: none;
            
            /* MARGEM ESQUERDA GRANDE PARA FACILITAR SELE√á√ÉO */
            padding: 20px 20px 20px 60px;
            
            /* Apar√™ncia */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            color: #333;
            position: relative;
            z-index: 1;
            overflow-y: auto;
            overflow-x: hidden;
            
            /* CAPS LOCK SEMPRE ATIVADO */
            text-transform: uppercase;
        }

        textarea::placeholder {
            color: #999;
        }

        /* Container de edi√ß√£o que permite texto e imagens */
        .editor-container {
            position: relative;
            min-height: 500px;
            padding: 20px 20px 20px 60px;
            font-size: 16px;
            line-height: 1.6;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            color: #333;
            white-space: pre-wrap;
            word-wrap: break-word;
            outline: none;
        }

        .editor-container:empty:before {
            content: attr(data-placeholder);
            color: #999;
        }

        /* √Årea clic√°vel para escrever */
        .notes-wrapper {
            position: relative;
            cursor: text;
            min-height: 100vh;
        }

        .notes-area {
            position: relative;
        }

        .toolbar {
            position: fixed;
            right: 15px;
            top: 40%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
        }

        button {
            padding: 10px 12px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 20px;
            font-weight: 500;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        button:hover {
            background: #45a049;
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        button:active {
            transform: scale(0.95);
        }

        .btn-secondary {
            background: #2196F3;
        }

        .btn-secondary:hover {
            background: #0b7dda;
        }

        .btn-danger {
            background: #f44336;
        }

        .btn-danger:hover {
            background: #da190b;
        }

        .btn-upload {
            background: #FF9800;
        }

        .btn-upload:hover {
            background: #F57C00;
        }

        /* Mini-menu do bot√£o de c√¢mera */
        .upload-menu-wrapper {
            position: relative;
        }

        .upload-menu {
            display: none;
            position: fixed;
            right: 68px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.25);
            overflow: hidden;
            z-index: 2000;
            min-width: 200px;
        }

        .upload-menu.open {
            display: block;
        }

        .upload-menu-item {
            padding: 14px 18px;
            font-size: 15px;
            font-weight: 500;
            color: #333;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            border-bottom: 1px solid #f0f0f0;
            transition: background 0.15s;
        }

        .upload-menu-item:last-child {
            border-bottom: none;
        }

        .upload-menu-item:hover, .upload-menu-item:active {
            background: #f5f5f5;
        }

        .btn-spacing {
            background: #9C27B0;
        }

        .btn-spacing:hover {
            background: #7B1FA2;
        }

        .btn-edit {
            background: #00BCD4;
        }

        .btn-edit:hover {
            background: #0097A7;
        }

        .btn-backup {
            background: #673AB7;
        }

        .btn-backup:hover {
            background: #5E35B1;
        }

        .btn-import {
            background: #009688;
        }

        .btn-import:hover {
            background: #00796B;
        }

        .status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1001;
            display: none;
        }

        #imageInput {
            display: none;
        }

        #importInput {
            display: none;
        }

        /* Estilos para imagens inseridas */
        .inserted-image {
            display: block;
            margin: 20px 0;
            max-width: 100%;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: move;
            position: relative;
        }

        .image-container {
            position: absolute;
            display: inline-block;
            z-index: 100;
            cursor: pointer;
            transition: box-shadow 0.2s;
        }

        .image-container.dragging {
            opacity: 0.7;
            z-index: 1000;
        }

        .image-container.active {
            box-shadow: 0 0 0 3px #4CAF50;
        }

        .image-container img {
            display: block;
            border: 2px solid #333;
            border-radius: 8px;
            pointer-events: none;
        }

        .resize-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #4CAF50;
            border: 2px solid white;
            border-radius: 50%;
            cursor: nwse-resize;
            z-index: 10;
        }

        .resize-handle.bottom-right {
            bottom: -10px;
            right: -10px;
        }

        .delete-image {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 30px;
            height: 30px;
            background: #f44336;
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            z-index: 11;
        }

        .delete-image:hover {
            background: #d32f2f;
            transform: scale(1.1);
        }

        .edit-image {
            position: absolute;
            top: -10px;
            left: -10px;
            width: 30px;
            height: 30px;
            background: #00BCD4;
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            z-index: 11;
        }

        .edit-image:hover {
            background: #0097A7;
            transform: scale(1.1);
        }

        /* EDITOR DE IMAGEM SOBREPOSTO */
        .image-editor-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            overflow: auto;
        }

        .image-editor-overlay.active {
            display: flex;
            flex-direction: column;
        }

        .editor-header {
            background: #333;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .editor-title {
            color: white;
            font-size: 18px;
            font-weight: 600;
        }

        .close-editor {
            background: #f44336;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .close-editor:hover {
            background: #d32f2f;
            transform: scale(1.1);
        }

        .editor-canvas-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow: auto;
        }

        #editorCanvas {
            max-width: 100%;
            max-height: calc(100vh - 200px);
            border: 2px solid #555;
            cursor: crosshair;
            touch-action: none;
        }

        .editor-footer {
            background: #1a1a1a;
            padding: 10px 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .footer-row {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: space-between;
        }

        .footer-row:first-child {
            justify-content: flex-start;
            gap: 8px;
        }

        .editor-btn {
            padding: 11px 18px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            white-space: nowrap;
        }

        .btn-clear {
            background: #FF5722;
            color: white;
        }

        .btn-clear:hover {
            background: #E64A19;
        }

        .btn-save {
            background: #4CAF50;
            color: white;
            margin-left: auto;
        }

        .btn-save:hover {
            background: #45a049;
        }

        .tool-selector {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .tool-btn {
            padding: 11px 16px;
            background: #2a2a2a;
            color: white;
            border: 2px solid #444;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
            white-space: nowrap;
        }

        .tool-btn.active {
            background: #00BCD4;
            border-color: #00BCD4;
        }

        .tool-btn:hover {
            background: #3a3a3a;
            border-color: #555;
        }

        .tool-btn.active:hover {
            background: #0097A7;
        }

        .color-picker-wrapper {
            display: flex;
            align-items: center;
            gap: 6px;
            background: #2a2a2a;
            padding: 7px 11px;
            border-radius: 8px;
            border: 2px solid #444;
        }

        .color-picker-label {
            color: white;
            font-size: 13px;
            font-weight: 500;
        }

        #colorPicker {
            width: 44px;
            height: 30px;
            border: 2px solid #666;
            border-radius: 6px;
            cursor: pointer;
            background: transparent;
        }

        /* Caixa flutuante arrast√°vel (fora do editor) */
        .floating-box {
            position: absolute;
            background: #111111;
            z-index: 200;
            cursor: move;
            min-width: 60px;
            min-height: 40px;
            border: 2px solid rgba(255,255,255,0.15);
            border-radius: 2px;
        }

        .floating-box .delete-box {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 24px;
            height: 24px;
            background: #f44336;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
            border: 2px solid white;
            z-index: 10;
        }

        .floating-box .edit-box {
            position: absolute;
            top: -10px;
            left: -10px;
            width: 24px;
            height: 24px;
            background: #00BCD4;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            cursor: pointer;
            border: 2px solid white;
            z-index: 10;
        }

        .floating-box .edit-box:hover {
            background: #0097A7;
        }

        .floating-box .resize-box-handle {
            position: absolute;
            bottom: -8px;
            right: -8px;
            width: 18px;
            height: 18px;
            background: white;
            border: 2px solid #333;
            border-radius: 50%;
            cursor: nwse-resize;
            z-index: 10;
        }

        .btn-floatbox {
            background: #E91E63;
        }

        .btn-floatbox:hover {
            background: #C2185B;
        }

        /* Bot√£o de grossura do l√°pis */
        .brush-size-wrapper {
            display: flex;
            align-items: center;
            gap: 5px;
            background: #2a2a2a;
            padding: 6px 10px;
            border-radius: 8px;
            border: 2px solid #444;
        }

        .brush-size-label {
            color: white;
            font-size: 13px;
            font-weight: 500;
        }

        #brushSizeInput, #textSizeInput {
            width: 90px;
            height: 28px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: #1a1a1a;
            accent-color: #00BCD4;
        }

        .brush-size-preview {
            color: white;
            font-size: 13px;
            min-width: 18px;
            text-align: center;
        }

        /* Bot√£o de adicionar texto no editor */
        .btn-text {
            background: #FF9800;
            color: white;
        }

        .btn-text:hover {
            background: #F57C00;
        }

        /* Textarea inline no canvas para texto */
        .canvas-text-input {
            position: fixed;
            z-index: 99999;
            background: rgba(255,255,255,0.15);
            border: 2px dashed #fff;
            color: inherit;
            font-size: 20px;
            font-weight: bold;
            padding: 4px 6px;
            outline: none;
            border-radius: 4px;
            min-width: 80px;
            min-height: 32px;
        }

        /* Texto flutuante arrast√°vel dentro do editor */
        .editor-text-label {
            touch-action: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚úçÔ∏è Minhas Anota√ß√µes</h1>
        </div>

        <div class="notes-area">
            <div class="notes-wrapper" id="notesWrapper">
                <textarea id="notepad" placeholder="Digite suas anota√ß√µes aqui..."></textarea>
            </div>
        </div>
    </div>

    <div class="toolbar">
        <button onclick="saveNote()" title="Salvar (Ctrl+S)">üíæ</button>
        <button onclick="copyNote()" title="Copiar texto" class="btn-secondary">üìã</button>
        <button onclick="takeScreenshot()" title="Capturar p√°gina inteira" class="btn-secondary">üì∏</button>
        <button onclick="goToWordStart()" title="In√≠cio da palavra" class="btn-secondary">‚èÆ</button>
        <button onclick="goToWordEnd()" title="Fim da palavra" class="btn-secondary">‚è≠</button>
        <button onclick="insertBlackHeart()" title="Inserir cora√ß√£o preto" class="btn-secondary">üñ§</button>
        <button onclick="addSpacing()" title="Adicionar 5 linhas" class="btn-spacing">üìè</button>
        <div class="upload-menu-wrapper">
            <button onclick="toggleUploadMenu(event)" title="Adicionar imagem" class="btn-upload">üì∑</button>
            <div class="upload-menu" id="uploadMenu">
                <div class="upload-menu-item" onclick="document.getElementById('imageInput').click(); closeUploadMenu()">üìÅ Arquivos / Galeria</div>
                <div class="upload-menu-item" onclick="openRearCamera(); closeUploadMenu()">üì∑ C√¢mera traseira</div>
            </div>
        </div>
        <button onclick="exportBackup()" title="Backup JSON" class="btn-backup">üì•</button>
        <button onclick="document.getElementById('importInput').click()" title="Importar backup" class="btn-import">üì¶</button>
        <button onclick="addFloatingBox()" title="Caixa colorida" class="btn-floatbox">‚¨õ</button>
        <button onclick="clearNote()" title="Limpar tudo" class="btn-danger">üóëÔ∏è</button>
    </div>

    <!-- Editor de Imagem Sobreposto -->
    <div class="image-editor-overlay" id="imageEditorOverlay">
        <div class="editor-header">
            <div class="editor-title">‚úèÔ∏è Editar Imagem</div>
            <button class="close-editor" onclick="closeImageEditor()">√ó</button>
        </div>
        
        <div class="editor-canvas-area">
            <canvas id="editorCanvas"></canvas>
        </div>
        
        <div class="editor-footer">
            <!-- Linha 1: ferramentas -->
            <div class="footer-row">
                <button class="tool-btn active" data-tool="pencil" onclick="selectTool('pencil')">‚úèÔ∏è L√°pis</button>
                <button class="tool-btn" data-tool="arrow" onclick="selectTool('arrow')">‚û°Ô∏è Seta</button>
                <button class="tool-btn" data-tool="box" onclick="selectTool('box')">‚¨õ Caixa</button>
                <button class="editor-btn btn-text" onclick="addTextToCanvas()">Texto+</button>
                <button class="editor-btn btn-save" onclick="saveEditedImage()">üíæ Salvar</button>
            </div>
            <!-- Linha 2: controles -->
            <div class="footer-row">
                <div class="color-picker-wrapper">
                    <label class="color-picker-label">Cor:</label>
                    <input type="color" id="colorPicker" value="#FF0000">
                </div>
                <div class="brush-size-wrapper">
                    <span class="brush-size-label">‚úèÔ∏è</span>
                    <input type="range" id="brushSizeInput" min="1" max="40" value="9">
                    <span class="brush-size-preview" id="brushSizePreview">9</span>
                </div>
                <div class="brush-size-wrapper">
                    <span class="brush-size-label">üî§</span>
                    <input type="range" id="textSizeInput" min="1" max="20" value="6">
                    <span class="brush-size-preview" id="textSizePreview">6</span>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="imageInput" accept="image/*">
    <input type="file" id="cameraInput" accept="image/*" capture="environment">
    <input type="file" id="importInput" accept=".json">

    <div class="status" id="status"></div>

    <script>
        const notepad = document.getElementById('notepad');
        const status = document.getElementById('status');
        const imageInput = document.getElementById('imageInput');
        const notesWrapper = document.getElementById('notesWrapper');
        
        let currentActiveImage = null;
        
        // Editor de imagem
        const editorOverlay = document.getElementById('imageEditorOverlay');
        const editorCanvas = document.getElementById('editorCanvas');
        const ctx = editorCanvas.getContext('2d');
        const colorPicker = document.getElementById('colorPicker');
        
        let currentTool = 'pencil';
        let isDrawing = false;
        let currentEditingContainer = null;
        let originalImageData = null;
        let baseImage = new Image();
        
        // Vari√°veis para desenho
        let lastX = 0;
        let lastY = 0;
        
        // Vari√°veis para seta
        let arrowStart = null;
        
        // Vari√°veis para caixa
        let boxStart = null;

        // Tamanho do l√°pis
        let brushSize = 9;
        let textSize = 6;
        
        const brushSizeInput = document.getElementById('brushSizeInput');
        const brushSizePreview = document.getElementById('brushSizePreview');
        if (brushSizeInput) {
            brushSizeInput.addEventListener('input', function() {
                brushSize = parseInt(this.value);
                brushSizePreview.textContent = brushSize;
            });
        }

        const textSizeInput = document.getElementById('textSizeInput');
        const textSizePreview = document.getElementById('textSizePreview');
        if (textSizeInput) {
            textSizeInput.addEventListener('input', function() {
                textSize = parseInt(this.value);
                textSizePreview.textContent = textSize;
            });
        }

        // Carregar anota√ß√£o salva
        window.addEventListener('load', function() {
            const saved = localStorage.getItem('myNote');
            if (saved) {
                notepad.value = saved;
            } else {
                // Se estiver vazio, adicionar 20 linhas em branco
                notepad.value = '\n'.repeat(20);
            }
            loadImages();
            notepad.focus();
            // Colocar cursor no in√≠cio
            notepad.setSelectionRange(0, 0);
            autoResizeTextarea();
            updateWrapperHeight();
        });

        // Auto-salvar enquanto digita
        notepad.addEventListener('input', function() {
            localStorage.setItem('myNote', notepad.value);
            autoResizeTextarea();
            updateWrapperHeight();
        });

        // Auto-resize do textarea
        function autoResizeTextarea() {
            notepad.style.height = 'auto';
            notepad.style.height = Math.max(notepad.scrollHeight, window.innerHeight) + 'px';
        }

        // Atualizar altura do wrapper para conter as imagens
        function updateWrapperHeight() {
            const containers = document.querySelectorAll('.image-container');
            let maxBottom = notepad.scrollHeight;
            
            containers.forEach(container => {
                const y = parseFloat(container.getAttribute('data-y')) || 0;
                const height = container.offsetHeight;
                const bottom = y + height + 100;
                if (bottom > maxBottom) {
                    maxBottom = bottom;
                }
            });
            
            notesWrapper.style.minHeight = maxBottom + 'px';
            notepad.style.minHeight = maxBottom + 'px';
        }

        // Upload de imagem
        imageInput.addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                // Mostrar status de processamento
                showStatus('Processando imagem... ‚è≥');
                
                const reader = new FileReader();
                reader.onload = async function(event) {
                    try {
                        // Comprimir para exibi√ß√£o (1MB - mais leve)
                        const compressedForDisplay = await compressImageForDisplay(event.target.result, 1024);
                        
                        // Calcular a posi√ß√£o Y baseada na posi√ß√£o do cursor
                        const cursorPosition = notepad.selectionStart;
                        const textBeforeCursor = notepad.value.substring(0, cursorPosition);
                        const lines = textBeforeCursor.split('\n');
                        const currentLineNumber = lines.length;
                        
                        // Altura de cada linha (aproximadamente 25.6px considerando line-height 1.6 e font-size 16px)
                        const lineHeight = 25.6;
                        const topPadding = 20; // padding-top do textarea
                        
                        // Posi√ß√£o Y = logo abaixo da linha atual
                        const yPosition = topPadding + (currentLineNumber * lineHeight) + 10;
                        
                        // Posi√ß√£o X = sempre √† esquerda (mesma posi√ß√£o do texto, considerando o padding-left de 60px)
                        const xPosition = 60;
                        
                        // Largura m√°xima de 175px
                        const maxWidth = 175;
                        
                        await createDraggableImage(compressedForDisplay, xPosition, yPosition, maxWidth);
                        showStatus('Imagem adicionada! üì∑');
                    } catch (err) {
                        console.error('Erro ao processar imagem:', err);
                        showStatus('Erro ao adicionar imagem ‚ùå');
                    }
                };
                reader.readAsDataURL(file);
            }
            imageInput.value = '';
        });

        // C√¢mera traseira ‚Äî mesmo handler do imageInput
        const cameraInput = document.getElementById('cameraInput');
        cameraInput.addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                showStatus('Processando imagem... ‚è≥');
                const reader = new FileReader();
                reader.onload = async function(event) {
                    try {
                        const compressedForDisplay = await compressImageForDisplay(event.target.result, 1024);
                        const cursorPosition = notepad.selectionStart;
                        const textBeforeCursor = notepad.value.substring(0, cursorPosition);
                        const lines = textBeforeCursor.split('\n');
                        const currentLineNumber = lines.length;
                        const lineHeight = 25.6;
                        const topPadding = 20;
                        const yPosition = topPadding + (currentLineNumber * lineHeight) + 10;
                        const xPosition = 60;
                        const maxWidth = 175;
                        await createDraggableImage(compressedForDisplay, xPosition, yPosition, maxWidth);
                        showStatus('Imagem adicionada! üì∑');
                    } catch (err) {
                        showStatus('Erro ao adicionar imagem ‚ùå');
                    }
                };
                reader.readAsDataURL(file);
            }
            cameraInput.value = '';
        });

        // Menu do bot√£o üì∑
        function toggleUploadMenu(e) {
            e.stopPropagation();
            const menu = document.getElementById('uploadMenu');
            const btn = e.currentTarget;
            const rect = btn.getBoundingClientRect();
            // Posicionar o menu acima do bot√£o
            menu.style.bottom = (window.innerHeight - rect.top + 8) + 'px';
            menu.classList.toggle('open');
        }

        function closeUploadMenu() {
            document.getElementById('uploadMenu').classList.remove('open');
        }

        // C√¢mera traseira via MediaDevices API (funciona em content:// no Android)
        function openRearCamera() {
            // getUserMedia s√≥ funciona em HTTPS (GitHub Pages) ‚Äî n√£o em content:// local
            const isSecure = location.protocol === 'https:' || location.hostname === 'localhost';

            if (!isSecure) {
                // Mostrar aviso explicativo
                const warn = document.createElement('div');
                warn.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0,0,0,0.92); z-index: 99999;
                    display: flex; flex-direction: column;
                    align-items: center; justify-content: center;
                    padding: 30px; text-align: center;
                `;
                warn.innerHTML = `
                    <div style="font-size:60px; margin-bottom:20px;">üì∑</div>
                    <div style="color:white; font-size:20px; font-weight:bold; margin-bottom:14px; line-height:1.4;">
                        C√¢mera traseira dispon√≠vel<br>somente no GitHub Pages
                    </div>
                    <div style="color:#aaa; font-size:15px; margin-bottom:30px; line-height:1.6;">
                        Quando acessar pelo GitHub (HTTPS),<br>
                        este bot√£o abrir√° direto a c√¢mera traseira.<br><br>
                        Por enquanto, use <b style="color:white">üìÅ Arquivos / Galeria</b><br>
                        e escolha a c√¢mera de l√°.
                    </div>
                    <button onclick="this.parentElement.remove()" style="
                        padding: 14px 36px; background: #4CAF50; color: white;
                        border: none; border-radius: 50px; font-size: 17px;
                        font-weight: bold; cursor: pointer;">
                        Entendido ‚úì
                    </button>
                `;
                document.body.appendChild(warn);
                return;
            }

            // ---- HTTPS: abre c√¢mera traseira via MediaDevices API ----
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: #000; z-index: 99999;
                display: flex; flex-direction: column;
                align-items: center; justify-content: center;
            `;

            const video = document.createElement('video');
            video.style.cssText = 'width: 100%; max-height: 80vh; object-fit: cover;';
            video.setAttribute('playsinline', '');
            video.setAttribute('autoplay', '');

            const btnBar = document.createElement('div');
            btnBar.style.cssText = `
                display: flex; gap: 20px; padding: 16px;
                width: 100%; justify-content: center;
            `;

            const captureBtn = document.createElement('button');
            captureBtn.textContent = 'üì∏ Fotografar';
            captureBtn.style.cssText = `
                padding: 16px 32px; background: #4CAF50; color: white;
                border: none; border-radius: 50px; font-size: 18px;
                font-weight: bold; cursor: pointer;
            `;

            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = '‚úï Cancelar';
            cancelBtn.style.cssText = `
                padding: 16px 28px; background: #f44336; color: white;
                border: none; border-radius: 50px; font-size: 18px;
                font-weight: bold; cursor: pointer;
            `;

            btnBar.appendChild(captureBtn);
            btnBar.appendChild(cancelBtn);
            overlay.appendChild(video);
            overlay.appendChild(btnBar);
            document.body.appendChild(overlay);

            let stream = null;

            // Tentar c√¢mera traseira exata, depois fallback suave
            navigator.mediaDevices.getUserMedia({
                video: { facingMode: { exact: 'environment' }, width: { ideal: 1920 }, height: { ideal: 1080 } }
            }).then(function(s) {
                stream = s;
                video.srcObject = stream;
            }).catch(function() {
                navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                }).then(function(s) {
                    stream = s;
                    video.srcObject = stream;
                }).catch(function(err) {
                    document.body.removeChild(overlay);
                    showStatus('Permiss√£o de c√¢mera negada ‚ùå');
                });
            });

            function stopCamera() {
                if (stream) stream.getTracks().forEach(t => t.stop());
                if (document.body.contains(overlay)) document.body.removeChild(overlay);
            }

            captureBtn.addEventListener('click', async function() {
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth || 1280;
                canvas.height = video.videoHeight || 720;
                canvas.getContext('2d').drawImage(video, 0, 0);
                stopCamera();

                const dataURL = canvas.toDataURL('image/jpeg', 0.92);
                showStatus('Processando imagem... ‚è≥');
                try {
                    const compressed = await compressImageForDisplay(dataURL, 1024);
                    const cursorPosition = notepad.selectionStart;
                    const lines = notepad.value.substring(0, cursorPosition).split('\n');
                    const yPosition = 20 + (lines.length * 25.6) + 10;
                    await createDraggableImage(compressed, 60, yPosition, 175);
                    showStatus('Foto adicionada! üì∑');
                } catch(err) {
                    showStatus('Erro ao processar foto ‚ùå');
                }
            });

            cancelBtn.addEventListener('click', stopCamera);
        }

        // Fechar menu ao clicar fora
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('uploadMenu');
            if (menu && menu.classList.contains('open')) {
                closeUploadMenu();
            }
        });
        async function createDraggableImage(src, x, y, width) {
            const container = document.createElement('div');
            container.className = 'image-container';
            container.style.position = 'absolute';
            container.style.left = x + 'px';
            container.style.top = y + 'px';
            container.style.width = width + 'px';
            container.setAttribute('data-x', x);
            container.setAttribute('data-y', y);
            container.setAttribute('data-width', width);
            
            const img = document.createElement('img');
            img.src = src;
            img.style.width = '100%';
            img.style.height = 'auto';
            
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-image';
            deleteBtn.innerHTML = '√ó';
            deleteBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                if (confirm('Deseja excluir esta imagem?')) {
                    container.remove();
                    if (currentActiveImage === container) {
                        currentActiveImage = null;
                    }
                    saveImages();
                    updateWrapperHeight();
                    showStatus('Imagem exclu√≠da!');
                }
            });
            
            const editBtn = document.createElement('div');
            editBtn.className = 'edit-image';
            editBtn.innerHTML = '‚úèÔ∏è';
            editBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                openImageEditor(container);
            });
            
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'resize-handle bottom-right';
            
            container.appendChild(img);
            container.appendChild(deleteBtn);
            container.appendChild(editBtn);
            container.appendChild(resizeHandle);
            notesWrapper.appendChild(container);
            
            // Click para selecionar
            container.addEventListener('click', function(e) {
                if (e.target === deleteBtn || e.target === resizeHandle) return;
                
                document.querySelectorAll('.image-container').forEach(c => c.classList.remove('active'));
                container.classList.add('active');
                currentActiveImage = container;
            });
            
            // Sistema de arrastar
            let isDragging = false;
            let dragStartX, dragStartY, elemStartX, elemStartY;
            
            container.addEventListener('mousedown', startDrag);
            container.addEventListener('touchstart', startDrag);
            
            function startDrag(e) {
                if (e.target === deleteBtn || e.target === editBtn || e.target === resizeHandle) return;
                
                isDragging = true;
                container.classList.add('dragging');
                
                dragStartX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
                dragStartY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
                
                elemStartX = parseFloat(container.getAttribute('data-x'));
                elemStartY = parseFloat(container.getAttribute('data-y'));
                
                e.preventDefault();
                e.stopPropagation();
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', stopDrag);
                document.addEventListener('touchmove', drag);
                document.addEventListener('touchend', stopDrag);
            }
            
            function drag(e) {
                if (!isDragging) return;
                
                const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
                const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
                
                const diffX = clientX - dragStartX;
                const diffY = clientY - dragStartY;
                
                const newX = elemStartX + diffX;
                const newY = elemStartY + diffY;
                
                container.style.left = newX + 'px';
                container.style.top = newY + 'px';
                container.setAttribute('data-x', newX);
                container.setAttribute('data-y', newY);
            }
            
            function stopDrag() {
                if (isDragging) {
                    isDragging = false;
                    container.classList.remove('dragging');
                    saveImages();
                    updateWrapperHeight();
                    document.removeEventListener('mousemove', drag);
                    document.removeEventListener('mouseup', stopDrag);
                    document.removeEventListener('touchmove', drag);
                    document.removeEventListener('touchend', stopDrag);
                }
            }
            
            // Sistema de resize
            let isResizing = false;
            let resizeStartX, resizeStartWidth;
            
            resizeHandle.addEventListener('mousedown', startResize);
            resizeHandle.addEventListener('touchstart', startResize);
            
            function startResize(e) {
                isResizing = true;
                resizeStartX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
                resizeStartWidth = parseInt(container.style.width);
                
                e.preventDefault();
                e.stopPropagation();
                
                document.addEventListener('mousemove', resize);
                document.addEventListener('mouseup', stopResize);
                document.addEventListener('touchmove', resize);
                document.addEventListener('touchend', stopResize);
            }
            
            function resize(e) {
                if (!isResizing) return;
                
                const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
                const diff = clientX - resizeStartX;
                const newWidth = Math.max(100, Math.min(800, resizeStartWidth + diff));
                
                container.style.width = newWidth + 'px';
                container.setAttribute('data-width', newWidth);
            }
            
            function stopResize() {
                if (isResizing) {
                    isResizing = false;
                    saveImages(); // async, mas n√£o precisa await aqui
                    updateWrapperHeight();
                    document.removeEventListener('mousemove', resize);
                    document.removeEventListener('mouseup', stopResize);
                    document.removeEventListener('touchmove', resize);
                    document.removeEventListener('touchend', stopResize);
                }
            }
            
            await saveImages(); // Aguardar o salvamento
            updateWrapperHeight();
        }

        // Salvar imagens no localStorage
        async function saveImages() {
            const containers = document.querySelectorAll('.image-container');
            const images = [];
            
            for (const container of containers) {
                const img = container.querySelector('img');
                
                // Comprimir imagem antes de salvar
                const compressedSrc = await compressImage(img.src, 450);
                
                images.push({
                    src: compressedSrc,
                    width: container.getAttribute('data-width'),
                    x: container.getAttribute('data-x'),
                    y: container.getAttribute('data-y')
                });
            }
            
            try {
                localStorage.setItem('myImages', JSON.stringify(images));
            } catch (err) {
                console.error('Erro ao salvar imagens no localStorage:', err);
            }
        }

        // Carregar imagens do localStorage
        function loadImages() {
            const saved = localStorage.getItem('myImages');
            if (saved) {
                const images = JSON.parse(saved);
                images.forEach(img => {
                    createDraggableImage(img.src, parseFloat(img.x), parseFloat(img.y), parseFloat(img.width));
                });
            }
        }

        // FUN√á√ïES DO EDITOR DE IMAGEM
        function openImageEditor(imageContainer) {
            if (!imageContainer) {
                showStatus('‚ö†Ô∏è Erro ao abrir editor!');
                return;
            }
            
            currentEditingContainer = imageContainer;
            const img = imageContainer.querySelector('img');
            
            // Carregar imagem no canvas
            baseImage.src = img.src;
            baseImage.onload = function() {
                editorCanvas.width = baseImage.width;
                editorCanvas.height = baseImage.height;
                
                // Desenhar imagem base
                ctx.drawImage(baseImage, 0, 0);
                
                // Salvar estado original
                originalImageData = ctx.getImageData(0, 0, editorCanvas.width, editorCanvas.height);
                
                // Mostrar editor
                editorOverlay.classList.add('active');
            };
        }

        function closeImageEditor() {
            // Remover textos flutuantes sem gravar
            editorTexts.forEach(function(t) { if (t.el.parentNode) t.el.remove(); });
            editorTexts = [];
            editorOverlay.classList.remove('active');
            currentEditingContainer = null;
            originalImageData = null;
            // Resetar tamanho do l√°pis visualmente
            if (brushSizeInput) {
                brushSizeInput.value = 9;
                brushSize = 9;
                if (brushSizePreview) brushSizePreview.textContent = 9;
            }
            if (textSizeInput) {
                textSizeInput.value = 6;
                textSize = 6;
                if (textSizePreview) textSizePreview.textContent = 6;
            }
        }

        function selectTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            const toolEl = document.querySelector(`[data-tool="${tool}"]`);
            if (toolEl) toolEl.classList.add('active');
            
            // Estilo do bot√£o Texto+
            const textBtn = document.querySelector('.btn-text');
            if (textBtn) {
                textBtn.style.background = (tool === 'text') ? '#E65100' : '';
            }

            editorCanvas.style.cursor = (tool === 'text') ? 'text' : 'crosshair';
        }

        function clearDrawing() {
            if (originalImageData) {
                ctx.putImageData(originalImageData, 0, 0);
            }
            showStatus('Desenho limpo!');
        }

        function saveEditedImage() {
            if (!currentEditingContainer) return;

            // Gravar todos os textos flutuantes no canvas antes de exportar
            commitAllEditorTexts();

            // Se for uma caixa flutuante
            if (currentEditingContainer._isBox) {
                const newDataURL = editorCanvas.toDataURL('image/png');
                const boxCanvas = currentEditingContainer._boxCanvas;
                const bCtx = boxCanvas.getContext('2d');
                const img = new Image();
                img.onload = function() {
                    bCtx.clearRect(0, 0, boxCanvas.width, boxCanvas.height);
                    bCtx.drawImage(img, 0, 0, boxCanvas.width, boxCanvas.height);
                };
                img.src = newDataURL;
                closeImageEditor();
                showStatus('‚úÖ Caixa salva!');
                return;
            }

            // Imagem normal
            const newImageSrc = editorCanvas.toDataURL('image/png');
            const imgEl = currentEditingContainer.querySelector('img');
            imgEl.src = newImageSrc;
            saveImages();
            closeImageEditor();
            showStatus('‚úÖ Imagem salva com sucesso!');
        }

        // Fun√ß√µes de desenho no canvas
        function getCanvasCoordinates(e) {
            const rect = editorCanvas.getBoundingClientRect();
            const scaleX = editorCanvas.width / rect.width;
            const scaleY = editorCanvas.height / rect.height;
            
            const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
            const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
            
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        // Mouse/Touch events para desenho
        editorCanvas.addEventListener('mousedown', startDrawing);
        editorCanvas.addEventListener('touchstart', startDrawing);
        editorCanvas.addEventListener('mousemove', draw);
        editorCanvas.addEventListener('touchmove', draw);
        editorCanvas.addEventListener('mouseup', stopDrawing);
        editorCanvas.addEventListener('touchend', stopDrawing);
        editorCanvas.addEventListener('mouseleave', stopDrawing);

        function startDrawing(e) {
            // Se ferramenta for texto, deixar o handleTextOnCanvas tratar
            if (currentTool === 'text') return;
            e.preventDefault();
            isDrawing = true;
            
            const coords = getCanvasCoordinates(e);
            lastX = coords.x;
            lastY = coords.y;
            
            if (currentTool === 'arrow') {
                arrowStart = { x: coords.x, y: coords.y };
            } else if (currentTool === 'box') {
                boxStart = { x: coords.x, y: coords.y };
            }
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            
            const coords = getCanvasCoordinates(e);
            
            if (currentTool === 'pencil') {
                // Desenho com l√°pis
                ctx.strokeStyle = colorPicker.value;
                ctx.lineWidth = brushSize;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(coords.x, coords.y);
                ctx.stroke();
                
                lastX = coords.x;
                lastY = coords.y;
            } else if (currentTool === 'arrow') {
                // Desenho de seta (preview em tempo real)
                if (arrowStart) {
                    // Restaurar imagem base + desenhos anteriores
                    ctx.putImageData(originalImageData, 0, 0);
                    
                    // Desenhar preview da seta
                    drawArrow(arrowStart.x, arrowStart.y, coords.x, coords.y, colorPicker.value);
                }
            } else if (currentTool === 'box') {
                // Desenho de caixa (preview em tempo real)
                if (boxStart) {
                    // Restaurar imagem base + desenhos anteriores
                    ctx.putImageData(originalImageData, 0, 0);
                    
                    // Desenhar preview da caixa
                    drawBox(boxStart.x, boxStart.y, coords.x, coords.y, colorPicker.value);
                }
            }
        }

        function stopDrawing(e) {
            if (!isDrawing) return;
            
            if (currentTool === 'arrow' && arrowStart) {
                const coords = getCanvasCoordinates(e);
                
                // Salvar o estado atual como novo original
                originalImageData = ctx.getImageData(0, 0, editorCanvas.width, editorCanvas.height);
            } else if (currentTool === 'box' && boxStart) {
                const coords = getCanvasCoordinates(e);
                
                // Salvar o estado atual como novo original
                originalImageData = ctx.getImageData(0, 0, editorCanvas.width, editorCanvas.height);
            }
            
            isDrawing = false;
            arrowStart = null;
            boxStart = null;
        }

        function drawArrow(fromX, fromY, toX, toY, color) {
            const headLength = 20;
            const angle = Math.atan2(toY - fromY, toX - fromX);
            
            // Linha principal
            ctx.strokeStyle = color;
            ctx.lineWidth = brushSize;
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            
            // Cabe√ßa da seta
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(
                toX - headLength * Math.cos(angle - Math.PI / 6),
                toY - headLength * Math.sin(angle - Math.PI / 6)
            );
            ctx.moveTo(toX, toY);
            ctx.lineTo(
                toX - headLength * Math.cos(angle + Math.PI / 6),
                toY - headLength * Math.sin(angle + Math.PI / 6)
            );
            ctx.stroke();
        }

        function drawBox(startX, startY, endX, endY, color) {
            const width = endX - startX;
            const height = endY - startY;
            
            // Desenhar ret√¢ngulo preenchido
            ctx.fillStyle = color;
            ctx.fillRect(startX, startY, width, height);
        }

        // ---- SISTEMA DE TEXTOS FLUTUANTES NO EDITOR ----
        // Os textos ficam como elementos arrast√°veis sobre o canvas.
        // S√≥ s√£o gravados nos pixels quando o usu√°rio clica em Salvar.

        let editorTexts = []; // { el, canvasX, canvasY, text, color, fontSize }

        function addTextToCanvas() {
            selectTool('text');
            showStatus('Toque na imagem para digitar ‚úçÔ∏è');
        }

        // Handler de texto no canvas
        function handleTextOnCanvas(e) {
            if (currentTool !== 'text') return;
            e.preventDefault();
            e.stopPropagation();

            const coords = getCanvasCoordinates(e);
            const rect = editorCanvas.getBoundingClientRect();
            const scaleX = rect.width / editorCanvas.width;
            const scaleY = rect.height / editorCanvas.height;

            // Posi√ß√£o visual na tela (relativa ao viewport)
            const screenX = rect.left + coords.x * scaleX;
            const screenY = rect.top + coords.y * scaleY;

            // Remover qualquer input de digita√ß√£o aberto
            const existing = document.querySelector('.canvas-text-input');
            if (existing && document.body.contains(existing)) document.body.removeChild(existing);

            // Criar input para o usu√°rio digitar
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'canvas-text-input';
            input.style.position = 'fixed';
            input.style.left = Math.min(screenX, window.innerWidth - 220) + 'px';
            input.style.top = Math.max(10, screenY - 22) + 'px';
            input.style.color = colorPicker.value;
            input.style.fontSize = Math.max(12, textSize * 6) + 'px';
            input.placeholder = 'Digite aqui...';
            document.body.appendChild(input);
            setTimeout(() => { input.focus(); }, 50);

            let committed = false;
            function commitText() {
                if (committed) return;
                committed = true;
                const text = input.value.trim();
                if (document.body.contains(input)) document.body.removeChild(input);

                if (text) {
                    const fontSize = Math.max(12, textSize * 6);
                    const color = colorPicker.value;

                    // Criar elemento flutuante arrast√°vel sobre o canvas
                    createFloatingEditorText(text, fontSize, color, coords, rect, scaleX, scaleY);
                    showStatus('Texto adicionado! Arraste para mover ‚úçÔ∏è');
                }

                // Voltar para l√°pis automaticamente ap√≥s adicionar texto
                selectTool('pencil');
            }

            input.addEventListener('keydown', function(ev) {
                if (ev.key === 'Enter') { ev.preventDefault(); commitText(); }
                if (ev.key === 'Escape') {
                    committed = true;
                    if (document.body.contains(input)) document.body.removeChild(input);
                    selectTool('pencil');
                }
            });
            input.addEventListener('blur', commitText);
        }

        function createFloatingEditorText(text, fontSize, color, canvasCoords, rect, scaleX, scaleY) {
            const editorArea = document.querySelector('.editor-canvas-area');

            const el = document.createElement('div');
            el.className = 'editor-text-label';
            el.textContent = text;
            el.style.cssText = `
                position: absolute;
                color: ${color};
                font-size: ${fontSize}px;
                font-family: Arial, sans-serif;
                font-weight: bold;
                cursor: move;
                user-select: none;
                white-space: nowrap;
                text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
                z-index: 500;
                padding: 3px 8px;
                background: rgba(100, 120, 160, 0.55);
                border: 1px dashed rgba(180, 200, 255, 0.55);
                border-radius: 4px;
            `;

            // Posicionar relativo √† √°rea do editor
            const areaRect = editorArea.getBoundingClientRect();
            const screenX = rect.left + canvasCoords.x * scaleX;
            const screenY = rect.top + canvasCoords.y * scaleY;
            let posX = screenX - areaRect.left;
            let posY = screenY - areaRect.top - fontSize * 0.5;
            el.style.left = posX + 'px';
            el.style.top = posY + 'px';

            // Bot√£o deletar o texto
            const delBtn = document.createElement('span');
            delBtn.textContent = '√ó';
            delBtn.style.cssText = `
                position: absolute;
                top: -8px; right: -8px;
                width: 18px; height: 18px;
                background: #f44336;
                color: white;
                border-radius: 50%;
                font-size: 13px;
                display: flex; align-items: center; justify-content: center;
                cursor: pointer;
                line-height: 1;
                border: 1px solid white;
            `;
            delBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                editorTexts = editorTexts.filter(t => t.el !== el);
                el.remove();
            });
            el.appendChild(delBtn);

            editorArea.style.position = 'relative';
            editorArea.appendChild(el);

            // Guardar refer√™ncia com coordenadas no canvas
            const textObj = { el, canvasCoords: { x: canvasCoords.x, y: canvasCoords.y }, text, color, fontSize, posX, posY };
            editorTexts.push(textObj);

            // ---- Arrastar o texto ----
            let isDragging = false, startMouseX, startMouseY, startPosX, startPosY;

            function startTextDrag(ev) {
                if (ev.target === delBtn) return;
                isDragging = true;
                startMouseX = ev.type.includes('touch') ? ev.touches[0].clientX : ev.clientX;
                startMouseY = ev.type.includes('touch') ? ev.touches[0].clientY : ev.clientY;
                startPosX = parseFloat(el.style.left);
                startPosY = parseFloat(el.style.top);
                ev.preventDefault(); ev.stopPropagation();
                document.addEventListener('mousemove', doTextDrag);
                document.addEventListener('mouseup', stopTextDrag);
                document.addEventListener('touchmove', doTextDrag, { passive: false });
                document.addEventListener('touchend', stopTextDrag);
            }
            function doTextDrag(ev) {
                if (!isDragging) return;
                const cx = ev.type.includes('touch') ? ev.touches[0].clientX : ev.clientX;
                const cy = ev.type.includes('touch') ? ev.touches[0].clientY : ev.clientY;
                const nx = startPosX + (cx - startMouseX);
                const ny = startPosY + (cy - startMouseY);
                el.style.left = nx + 'px';
                el.style.top = ny + 'px';
                textObj.posX = nx;
                textObj.posY = ny;
                ev.preventDefault();
            }
            function stopTextDrag() {
                if (!isDragging) return;
                isDragging = false;
                // Atualizar coordenadas no canvas
                const areaRect = editorArea.getBoundingClientRect();
                const canvasRect = editorCanvas.getBoundingClientRect();
                const sx = editorCanvas.width / canvasRect.width;
                const sy = editorCanvas.height / canvasRect.height;
                const absX = areaRect.left + textObj.posX;
                const absY = areaRect.top + textObj.posY + fontSize * 0.5;
                textObj.canvasCoords.x = (absX - canvasRect.left) * sx;
                textObj.canvasCoords.y = (absY - canvasRect.top) * sy;
                document.removeEventListener('mousemove', doTextDrag);
                document.removeEventListener('mouseup', stopTextDrag);
                document.removeEventListener('touchmove', doTextDrag);
                document.removeEventListener('touchend', stopTextDrag);
            }

            el.addEventListener('mousedown', startTextDrag);
            el.addEventListener('touchstart', startTextDrag, { passive: false });
        }

        // Gravar todos os textos flutuantes no canvas ao salvar
        function commitAllEditorTexts() {
            editorTexts.forEach(function(t) {
                ctx.font = `bold ${t.fontSize}px Arial, sans-serif`;

                // Medir largura do texto para desenhar o fundo
                const metrics = ctx.measureText(t.text);
                const textW = metrics.width;
                const textH = t.fontSize;
                const padX = t.fontSize * 0.2;
                const padY = t.fontSize * 0.15;
                const bx = t.canvasCoords.x - padX;
                const by = t.canvasCoords.y + t.fontSize * 0.35 - textH * 0.85 - padY;
                const bw = textW + padX * 2;
                const bh = textH + padY * 2;

                // Fundo cinza levemente azulado (igual ao visual)
                ctx.fillStyle = 'rgba(100, 120, 160, 0.55)';
                ctx.beginPath();
                ctx.roundRect ? ctx.roundRect(bx, by, bw, bh, 4) : ctx.rect(bx, by, bw, bh);
                ctx.fill();

                // Texto por cima
                ctx.fillStyle = t.color;
                ctx.fillText(t.text, t.canvasCoords.x, t.canvasCoords.y + t.fontSize * 0.35);
            });
            // Limpar textos flutuantes
            editorTexts.forEach(function(t) { t.el.remove(); });
            editorTexts = [];
        }

        editorCanvas.addEventListener('mousedown', handleTextOnCanvas);
        editorCanvas.addEventListener('touchstart', handleTextOnCanvas, { passive: false });

        // ---- CAIXA FLUTUANTE (fora do editor) ----

        function addFloatingBox() {
            const box = document.createElement('div');
            box.className = 'floating-box';
            box.style.width = '240px';
            box.style.height = '140px';
            box.style.left = '80px';
            box.style.top = (window.scrollY + 200) + 'px';
            box.setAttribute('data-x', 80);
            box.setAttribute('data-y', window.scrollY + 200);

            // Criar canvas interno que representa o "conte√∫do" da caixa
            const boxCanvas = document.createElement('canvas');
            boxCanvas.width = 240;
            boxCanvas.height = 140;
            boxCanvas.style.width = '100%';
            boxCanvas.style.height = '100%';
            boxCanvas.style.display = 'block';
            boxCanvas.style.borderRadius = '2px';
            // Pintar fundo preto inicial
            const bCtx = boxCanvas.getContext('2d');
            bCtx.fillStyle = '#111111';
            bCtx.fillRect(0, 0, boxCanvas.width, boxCanvas.height);

            // Bot√£o deletar (vermelho, topo direito)
            const del = document.createElement('div');
            del.className = 'delete-box';
            del.innerHTML = '√ó';
            del.addEventListener('click', function(e) {
                e.stopPropagation();
                box.remove();
            });

            // Bot√£o editar (l√°pis, topo esquerdo ‚Äî igual √†s fotos)
            const editBtn = document.createElement('div');
            editBtn.className = 'edit-box';
            editBtn.innerHTML = '‚úèÔ∏è';
            editBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                // Abrir o editor de imagem com o canvas da caixa como "imagem"
                openBoxEditor(box, boxCanvas);
            });

            // Handle de resize (canto inferior direito)
            const resizeH = document.createElement('div');
            resizeH.className = 'resize-box-handle';

            box.appendChild(boxCanvas);
            box.appendChild(del);
            box.appendChild(editBtn);
            box.appendChild(resizeH);
            notesWrapper.appendChild(box);

            // ---- Arrastar ----
            let isDrag = false, dsx, dsy, bsx, bsy;

            function startBoxDrag(e) {
                if (e.target === del || e.target === editBtn || e.target === resizeH) return;
                isDrag = true;
                box.style.opacity = '0.85';
                dsx = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
                dsy = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
                bsx = parseFloat(box.getAttribute('data-x')) || 80;
                bsy = parseFloat(box.getAttribute('data-y')) || 200;
                e.preventDefault(); e.stopPropagation();
                document.addEventListener('mousemove', doBoxDrag);
                document.addEventListener('mouseup', stopBoxDrag);
                document.addEventListener('touchmove', doBoxDrag, { passive: false });
                document.addEventListener('touchend', stopBoxDrag);
            }
            function doBoxDrag(e) {
                if (!isDrag) return;
                const cx = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
                const cy = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
                const nx = bsx + cx - dsx;
                const ny = bsy + cy - dsy;
                box.style.left = nx + 'px';
                box.style.top = ny + 'px';
                box.setAttribute('data-x', nx);
                box.setAttribute('data-y', ny);
                e.preventDefault();
            }
            function stopBoxDrag() {
                if (!isDrag) return;
                isDrag = false;
                box.style.opacity = '1';
                document.removeEventListener('mousemove', doBoxDrag);
                document.removeEventListener('mouseup', stopBoxDrag);
                document.removeEventListener('touchmove', doBoxDrag);
                document.removeEventListener('touchend', stopBoxDrag);
            }
            box.addEventListener('mousedown', startBoxDrag);
            box.addEventListener('touchstart', startBoxDrag, { passive: false });

            // ---- Resize ----
            let isRes = false, rsx, rsy, rwStart, rhStart;

            function startBoxResize(e) {
                isRes = true;
                rsx = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
                rsy = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
                rwStart = box.offsetWidth;
                rhStart = box.offsetHeight;
                e.preventDefault(); e.stopPropagation();
                document.addEventListener('mousemove', doBoxResize);
                document.addEventListener('mouseup', stopBoxResize);
                document.addEventListener('touchmove', doBoxResize, { passive: false });
                document.addEventListener('touchend', stopBoxResize);
            }
            function doBoxResize(e) {
                if (!isRes) return;
                const cx = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
                const cy = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
                const newW = Math.max(40, rwStart + (cx - rsx));
                const newH = Math.max(25, rhStart + (cy - rsy));
                box.style.width = newW + 'px';
                box.style.height = newH + 'px';
                // Redimensionar canvas interno tamb√©m
                const imgData = bCtx.getImageData(0, 0, boxCanvas.width, boxCanvas.height);
                boxCanvas.width = newW;
                boxCanvas.height = newH;
                bCtx.putImageData(imgData, 0, 0);
                e.preventDefault();
            }
            function stopBoxResize() {
                if (!isRes) return;
                isRes = false;
                document.removeEventListener('mousemove', doBoxResize);
                document.removeEventListener('mouseup', stopBoxResize);
                document.removeEventListener('touchmove', doBoxResize);
                document.removeEventListener('touchend', stopBoxResize);
            }
            resizeH.addEventListener('mousedown', startBoxResize);
            resizeH.addEventListener('touchstart', startBoxResize, { passive: false });

            showStatus('Caixa adicionada! Arraste para posicionar ‚¨õ');
        }

        // Abrir editor de imagem para uma caixa flutuante
        function openBoxEditor(box, boxCanvas) {
            const fakeContainer = {
                _isBox: true,
                _box: box,
                _boxCanvas: boxCanvas,
                querySelector: function(sel) {
                    if (sel === 'img') {
                        return { src: boxCanvas.toDataURL('image/png'), _fakeImg: true };
                    }
                }
            };

            currentEditingContainer = fakeContainer;

            // Escalar para resolu√ß√£o maior para edi√ß√£o confort√°vel (m√≠nimo 600px largura)
            const dataURL = boxCanvas.toDataURL('image/png');
            const tempImg = new Image();
            tempImg.onload = function() {
                const scale = Math.max(1, Math.ceil(600 / boxCanvas.width));
                editorCanvas.width  = boxCanvas.width  * scale;
                editorCanvas.height = boxCanvas.height * scale;
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(tempImg, 0, 0, editorCanvas.width, editorCanvas.height);
                originalImageData = ctx.getImageData(0, 0, editorCanvas.width, editorCanvas.height);
                editorOverlay.classList.add('active');
            };
            tempImg.src = dataURL;
        }

        // Inserir cora√ß√£o preto
        function insertBlackHeart() {
            const start = notepad.selectionStart;
            const end = notepad.selectionEnd;
            const text = notepad.value;
            const before = text.substring(0, start);
            const after = text.substring(end);
            
            notepad.value = before + '  üñ§  ' + after;
            
            const newPosition = start + 6;
            notepad.setSelectionRange(newPosition, newPosition);
            notepad.focus();
            
            localStorage.setItem('myNote', notepad.value);
            showStatus('Cora√ß√£o preto inserido! üñ§');
        }

        // Salvar manualmente
        async function saveNote() {
            localStorage.setItem('myNote', notepad.value);
            saveImages();
            
            // Salvar imagens comprimidas no localStorage tamb√©m
            try {
                const imageContainers = document.querySelectorAll('.image-container');
                const compressedImages = [];
                
                for (const container of imageContainers) {
                    const img = container.querySelector('img');
                    if (img) {
                        // Comprimir imagem
                        const compressedSrc = await compressImage(img.src, 450);
                        
                        compressedImages.push({
                            src: compressedSrc,
                            width: img.width,
                            height: img.height,
                            x: parseFloat(container.getAttribute('data-x')) || 0,
                            y: parseFloat(container.getAttribute('data-y')) || 0
                        });
                    }
                }
                
                if (compressedImages.length > 0) {
                    localStorage.setItem('myImages', JSON.stringify(compressedImages));
                }
                
                showStatus('Anota√ß√£o e imagens salvas! ‚úì');
            } catch (err) {
                console.error('Erro ao salvar imagens:', err);
                showStatus('Texto salvo! (erro ao salvar imagens)');
            }
        }

        // Copiar texto e imagens
        async function copyNote() {
            try {
                const text = notepad.value;
                const images = document.querySelectorAll('.image-container img');
                
                // Criar um HTML com texto e imagens
                let htmlContent = '<div style="font-family: -apple-system, BlinkMacSystemFont, \'Segoe UI\', Roboto, Arial, sans-serif; white-space: pre-wrap;">';
                htmlContent += text.replace(/\n/g, '<br>');
                htmlContent += '</div>';
                
                // Adicionar imagens ao HTML
                images.forEach(img => {
                    htmlContent += `<img src="${img.src}" style="max-width: 100%; margin: 20px 0; border: 2px solid #ddd; border-radius: 8px;">`;
                });
                
                // Criar blob com HTML
                const htmlBlob = new Blob([htmlContent], { type: 'text/html' });
                const textBlob = new Blob([text], { type: 'text/plain' });
                
                // Copiar para clipboard com m√∫ltiplos formatos
                const clipboardItem = new ClipboardItem({
                    'text/html': htmlBlob,
                    'text/plain': textBlob
                });
                
                await navigator.clipboard.write([clipboardItem]);
                showStatus('Texto e imagens copiados! ‚úì');
            } catch (err) {
                console.error('Erro ao copiar:', err);
                // Fallback: copiar apenas texto
                const text = notepad.value;
                navigator.clipboard.writeText(text).then(() => {
                    showStatus('Texto copiado (imagens n√£o suportadas)');
                }).catch(() => {
                    notepad.select();
                    document.execCommand('copy');
                    showStatus('Texto copiado (imagens n√£o suportadas)');
                });
            }
        }

        // Ir para o in√≠cio da palavra selecionada
        function goToWordStart() {
            const start = notepad.selectionStart;
            const text = notepad.value;
            
            if (start === 0) return;
            
            let pos = start;
            
            while (pos > 0 && /\s/.test(text[pos - 1])) {
                pos--;
            }
            
            while (pos > 0 && !/\s/.test(text[pos - 1])) {
                pos--;
            }
            
            notepad.setSelectionRange(pos, pos);
            notepad.focus();
            showStatus('Cursor no in√≠cio da palavra');
        }

        // Ir para o final da palavra selecionada
        function goToWordEnd() {
            const start = notepad.selectionStart;
            const text = notepad.value;
            const len = text.length;
            
            if (start === len) return;
            
            let pos = start;
            
            while (pos < len && /\s/.test(text[pos])) {
                pos++;
            }
            
            while (pos < len && !/\s/.test(text[pos])) {
                pos++;
            }
            
            notepad.setSelectionRange(pos, pos);
            notepad.focus();
            showStatus('Cursor no final da palavra');
        }

        // Limpar anota√ß√µes
        function clearNote() {
            if (confirm('Tem certeza que deseja limpar todas as anota√ß√µes e imagens?')) {
                notepad.value = '\n'.repeat(20);
                localStorage.setItem('myNote', notepad.value);
                localStorage.removeItem('myImages');
                document.querySelectorAll('.image-container').forEach(c => c.remove());
                currentActiveImage = null;
                notepad.setSelectionRange(0, 0);
                notepad.focus();
                autoResizeTextarea();
                updateWrapperHeight();
                showStatus('Anota√ß√µes limpas!');
            }
        }

        // Adicionar 5 linhas vazias
        function addSpacing() {
            const start = notepad.selectionStart;
            const end = notepad.selectionEnd;
            const text = notepad.value;
            const before = text.substring(0, start);
            const after = text.substring(end);
            
            const spacing = '\n'.repeat(5);
            
            notepad.value = before + spacing + after;
            
            const newPosition = start + spacing.length;
            notepad.setSelectionRange(newPosition, newPosition);
            notepad.focus();
            
            localStorage.setItem('myNote', notepad.value);
            autoResizeTextarea();
            updateWrapperHeight();
            showStatus('5 linhas adicionadas! üìè');
        }

        // Mostrar mensagem de status
        function showStatus(message) {
            status.textContent = message;
            status.style.display = 'block';
            setTimeout(() => {
                status.style.display = 'none';
            }, 3000);
        }

        // Capturar p√°gina inteira como imagem
        async function takeScreenshot() {
            showStatus('Capturando p√°gina... üì∏');
            
            // Esconder a toolbar temporariamente
            const toolbar = document.querySelector('.toolbar');
            const statusEl = document.querySelector('.status');
            toolbar.style.display = 'none';
            statusEl.style.display = 'none';
            
            try {
                // Capturar a p√°gina inteira
                const canvas = await html2canvas(document.body, {
                    scale: 2, // Qualidade maior
                    useCORS: true,
                    allowTaint: true,
                    backgroundColor: '#ffffff',
                    scrollY: -window.scrollY,
                    scrollX: -window.scrollX,
                    windowWidth: document.documentElement.scrollWidth,
                    windowHeight: document.documentElement.scrollHeight
                });
                
                // Mostrar toolbar novamente
                toolbar.style.display = 'flex';
                
                // Converter canvas para blob
                canvas.toBlob(async function(blob) {
                    // Tentar compartilhar (funciona melhor no Android)
                    if (navigator.share && navigator.canShare && navigator.canShare({ files: [new File([blob], 'notas.png', { type: 'image/png' })] })) {
                        try {
                            const file = new File([blob], 'minhas-notas.png', { type: 'image/png' });
                            await navigator.share({
                                files: [file],
                                title: 'Minhas Anota√ß√µes',
                                text: 'Captura das minhas anota√ß√µes'
                            });
                            showStatus('Imagem compartilhada! ‚úì');
                        } catch (err) {
                            // Se cancelar o compartilhamento, mostra a imagem
                            if (err.name !== 'AbortError') {
                                showImagePreview(blob);
                            }
                        }
                    } else {
                        // Se n√£o suportar share, mostra a imagem para salvar
                        showImagePreview(blob);
                    }
                });
            } catch (err) {
                console.error('Erro ao capturar:', err);
                toolbar.style.display = 'flex';
                showStatus('Erro ao capturar imagem ‚ùå');
            }
        }
        
        // Mostrar preview da imagem para salvar manualmente
        function showImagePreview(blob) {
            const url = URL.createObjectURL(blob);
            
            // Criar overlay com a imagem
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.95);
                z-index: 99999;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            const instruction = document.createElement('div');
            instruction.style.cssText = `
                color: white;
                font-size: 18px;
                text-align: center;
                margin-bottom: 20px;
                padding: 15px;
                background: rgba(76, 175, 80, 0.8);
                border-radius: 10px;
            `;
            instruction.innerHTML = 'üì∏ Segure na imagem e escolha "Salvar imagem"<br>ou "Baixar imagem"';
            
            const img = document.createElement('img');
            img.src = url;
            img.style.cssText = `
                max-width: 100%;
                max-height: 70vh;
                border: 3px solid #4CAF50;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            `;
            
            const closeBtn = document.createElement('button');
            closeBtn.textContent = '‚úï Fechar';
            closeBtn.style.cssText = `
                margin-top: 20px;
                padding: 15px 30px;
                background: #f44336;
                color: white;
                border: none;
                border-radius: 25px;
                font-size: 18px;
                font-weight: bold;
                cursor: pointer;
            `;
            closeBtn.onclick = () => {
                document.body.removeChild(overlay);
                URL.revokeObjectURL(url);
            };
            
            overlay.appendChild(instruction);
            overlay.appendChild(img);
            overlay.appendChild(closeBtn);
            document.body.appendChild(overlay);
            
            showStatus('Segure na imagem para salvar! üëÜ');
        }

        // Atalhos de teclado
        notepad.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                saveNote();
            }
        });

        // Exportar backup em JSON
        async function exportBackup() {
            try {
                // Coletar dados do texto
                const text = notepad.value;
                
                // Coletar dados das imagens
                const images = [];
                const imageContainers = document.querySelectorAll('.image-container');
                
                imageContainers.forEach((container, index) => {
                    const img = container.querySelector('img');
                    if (img) {
                        images.push({
                            src: img.src,
                            width: container.getAttribute('data-width') || img.width,
                            x: container.getAttribute('data-x') || parseFloat(container.style.left) || 100,
                            y: container.getAttribute('data-y') || parseFloat(container.style.top) || 100,
                            index: index
                        });
                    }
                });
                
                // Criar objeto de backup
                const backup = {
                    version: '1.0',
                    date: new Date().toISOString(),
                    text: text,
                    images: images
                };
                
                // Converter para JSON
                const jsonString = JSON.stringify(backup, null, 2);
                
                // Criar blob
                const blob = new Blob([jsonString], { type: 'application/json' });
                
                // Criar nome do arquivo com data
                const now = new Date();
                const day = String(now.getDate()).padStart(2, '0');
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const year = now.getFullYear();
                const filename = `BACKUP_NOTAS_FACULDADE_${day}-${month}-${year}.json`;
                
                // Tentar usar a File System Access API (Chrome Android 108+)
                if ('showSaveFilePicker' in window) {
                    try {
                        const options = {
                            suggestedName: filename,
                            types: [{
                                description: 'JSON Files',
                                accept: { 'application/json': ['.json'] }
                            }]
                        };
                        
                        const handle = await window.showSaveFilePicker(options);
                        const writable = await handle.createWritable();
                        await writable.write(blob);
                        await writable.close();
                        
                        showStatus(`Backup exportado! üì¶ (${images.length} imagens)`);
                        return;
                    } catch (err) {
                        // Usu√°rio cancelou ou erro - vamos usar fallback
                        if (err.name !== 'AbortError') {
                            console.log('Erro ao usar showSaveFilePicker:', err);
                        } else {
                            return; // Usu√°rio cancelou
                        }
                    }
                }
                
                // Fallback para navegadores que n√£o suportam ou se usu√°rio cancelou
                // Tenta usar Web Share API (dispon√≠vel no Android)
                if (navigator.share && navigator.canShare && navigator.canShare({ files: [new File([blob], 'test.json')] })) {
                    try {
                        const file = new File([blob], filename, { type: 'application/json' });
                        
                        await navigator.share({
                            files: [file],
                            title: 'Exportar Backup',
                            text: 'Arquivo de backup das notas da faculdade'
                        });
                        
                        showStatus(`Arquivo compartilhado! üì¶ (${images.length} imagens)`);
                        return;
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            console.log('Erro ao compartilhar:', err);
                        } else {
                            return; // Usu√°rio cancelou
                        }
                    }
                }
                
                // Fallback final: download tradicional
                const url = URL.createObjectURL(blob);
                
                // Criar link tempor√°rio para download
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showStatus(`Backup exportado! üì¶ (${images.length} imagens)`);
            } catch (err) {
                console.error('Erro ao exportar backup:', err);
                showStatus('Erro ao exportar backup ‚ùå');
            }
        }

        // Backup autom√°tico silencioso (sem notifica√ß√£o)
        function autoBackup() {
            try {
                // Coletar dados do texto
                const text = notepad.value;
                
                // Coletar dados das imagens
                const images = [];
                const imageContainers = document.querySelectorAll('.image-container');
                
                imageContainers.forEach((container, index) => {
                    const img = container.querySelector('img');
                    if (img) {
                        images.push({
                            src: img.src,
                            width: container.getAttribute('data-width') || img.width,
                            x: container.getAttribute('data-x') || parseFloat(container.style.left) || 100,
                            y: container.getAttribute('data-y') || parseFloat(container.style.top) || 100,
                            index: index
                        });
                    }
                });
                
                // Criar objeto de backup
                const backup = {
                    version: '1.0',
                    date: new Date().toISOString(),
                    text: text,
                    images: images
                };
                
                // Converter para JSON
                const jsonString = JSON.stringify(backup, null, 2);
                
                // Criar blob e download
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // Criar nome do arquivo com data
                const now = new Date();
                const day = String(now.getDate()).padStart(2, '0');
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const year = now.getFullYear();
                const filename = `BACKUP_NOTAS_FACULDADE_${day}-${month}-${year}.json`;
                
                // Criar link tempor√°rio para download (silencioso)
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Sem notifica√ß√£o visual
            } catch (err) {
                console.error('Erro no backup autom√°tico:', err);
                // Falha silenciosa, sem notifica√ß√£o ao usu√°rio
            }
        }

        // Iniciar backup autom√°tico a cada 6 minutos (360000 ms)
        setInterval(autoBackup, 360000);

        // Fun√ß√£o para comprimir imagem para menos de 450KB
        async function compressImage(imageSrc, maxSizeKB = 450) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Calcular redimensionamento inicial
                    let width = img.width;
                    let height = img.height;
                    
                    // Se a imagem for muito grande, reduzir dimens√µes primeiro
                    const maxDimension = 1200;
                    if (width > maxDimension || height > maxDimension) {
                        const ratio = Math.min(maxDimension / width, maxDimension / height);
                        width = Math.floor(width * ratio);
                        height = Math.floor(height * ratio);
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Tentar com qualidade 0.6
                    let result = canvas.toDataURL('image/jpeg', 0.6);
                    let sizeKB = (result.length * 3) / 4 / 1024;
                    
                    // Se ainda estiver grande, reduzir mais
                    if (sizeKB > maxSizeKB) {
                        result = canvas.toDataURL('image/jpeg', 0.4);
                        sizeKB = (result.length * 3) / 4 / 1024;
                    }
                    
                    // Se AINDA estiver grande, reduzir dimens√µes
                    if (sizeKB > maxSizeKB) {
                        width = Math.floor(width * 0.6);
                        height = Math.floor(height * 0.6);
                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);
                        result = canvas.toDataURL('image/jpeg', 0.5);
                    }
                    
                    resolve(result);
                };
                
                img.onerror = function() {
                    resolve(imageSrc);
                };
                
                img.src = imageSrc;
            });
        }

        // Fun√ß√£o para comprimir imagem para EXIBI√á√ÉO (1MB - mais r√°pido e melhor qualidade visual)
        async function compressImageForDisplay(imageSrc, maxSizeKB = 1024) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Calcular redimensionamento inicial baseado no tamanho da imagem
                    let width = img.width;
                    let height = img.height;
                    
                    // Se a imagem for muito grande, reduzir dimens√µes primeiro (otimiza√ß√£o)
                    const maxDimension = 1500; // M√°ximo 1500px
                    if (width > maxDimension || height > maxDimension) {
                        const ratio = Math.min(maxDimension / width, maxDimension / height);
                        width = Math.floor(width * ratio);
                        height = Math.floor(height * ratio);
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Tentar com qualidade 0.7 primeiro (boa qualidade, bom tamanho)
                    let result = canvas.toDataURL('image/jpeg', 0.7);
                    let sizeKB = (result.length * 3) / 4 / 1024;
                    
                    // Se ainda estiver muito grande, tentar qualidade 0.5
                    if (sizeKB > maxSizeKB) {
                        result = canvas.toDataURL('image/jpeg', 0.5);
                        sizeKB = (result.length * 3) / 4 / 1024;
                    }
                    
                    // Se AINDA estiver grande, reduzir dimens√µes mais
                    if (sizeKB > maxSizeKB) {
                        width = Math.floor(width * 0.7);
                        height = Math.floor(height * 0.7);
                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);
                        result = canvas.toDataURL('image/jpeg', 0.6);
                    }
                    
                    resolve(result);
                };
                
                img.onerror = function() {
                    resolve(imageSrc); // Retornar original se houver erro
                };
                
                img.src = imageSrc;
            });
        }

        // Salvar texto E imagens comprimidas no localStorage a cada 1 minuto (60000 ms)
        setInterval(async function() {
            try {
                // Salvar texto
                localStorage.setItem('myNote', notepad.value);
                
                // Salvar imagens comprimidas
                const imageContainers = document.querySelectorAll('.image-container');
                const compressedImages = [];
                
                for (const container of imageContainers) {
                    const img = container.querySelector('img');
                    if (img) {
                        // Comprimir imagem
                        const compressedSrc = await compressImage(img.src, 450);
                        
                        compressedImages.push({
                            src: compressedSrc,
                            width: img.width,
                            height: img.height,
                            x: parseFloat(container.getAttribute('data-x')) || 0,
                            y: parseFloat(container.getAttribute('data-y')) || 0
                        });
                    }
                }
                
                if (compressedImages.length > 0) {
                    localStorage.setItem('myImages', JSON.stringify(compressedImages));
                }
                
            } catch (err) {
                console.error('Erro ao salvar no localStorage:', err);
                // Se estourar o limite de storage, tentar salvar apenas o texto
                try {
                    localStorage.setItem('myNote', notepad.value);
                } catch (e) {
                    console.error('Erro cr√≠tico ao salvar texto:', e);
                }
            }
        }, 60000);

        // Importar backup do JSON
        const importInput = document.getElementById('importInput');
        
        importInput.addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            
            reader.onload = async function(event) {
                try {
                    const backup = JSON.parse(event.target.result);
                    
                    // Validar estrutura do backup
                    if (!backup.version || backup.text === undefined) {
                        throw new Error('Formato de backup inv√°lido');
                    }
                    
                    // Confirmar importa√ß√£o
                    if (!confirm(`Importar backup de ${new Date(backup.date).toLocaleString()}?\n\nIsso substituir√° todas as anota√ß√µes atuais.`)) {
                        importInput.value = '';
                        return;
                    }
                    
                    showStatus('Importando backup... ‚è≥');
                    
                    // Limpar dados atuais
                    document.querySelectorAll('.image-container').forEach(c => c.remove());
                    currentActiveImage = null;
                    
                    // Restaurar texto
                    notepad.value = backup.text;
                    localStorage.setItem('myNote', backup.text);
                    
                    // Restaurar imagens usando createDraggableImage
                    if (backup.images && backup.images.length > 0) {
                        for (const imgData of backup.images) {
                            const x = parseFloat(imgData.x) || parseFloat(imgData.left) || 100;
                            const y = parseFloat(imgData.y) || parseFloat(imgData.top) || 100;
                            const width = parseFloat(imgData.width) || 175;
                            
                            await createDraggableImage(imgData.src, x, y, width);
                        }
                        
                        showStatus(`Backup importado! ‚úì (${backup.images.length} imagens)`);
                    } else {
                        showStatus('Backup importado! ‚úì');
                    }
                    
                    autoResizeTextarea();
                    updateWrapperHeight();
                    
                } catch (err) {
                    console.error('Erro ao importar backup:', err);
                    alert('Erro ao importar backup!\n\nVerifique se o arquivo √© um backup v√°lido.');
                    showStatus('Erro ao importar backup ‚ùå');
                }
                
                // Limpar input
                importInput.value = '';
            };
            
            reader.onerror = function() {
                showStatus('Erro ao ler arquivo ‚ùå');
                importInput.value = '';
            };
            
            reader.readAsText(file);
        });
    </script>
</body>
</html>
